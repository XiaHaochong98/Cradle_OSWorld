import multiprocessing
import os
import time
import numpy as np
from uac.log import Logger
import subprocess
import shutil
from uac.config import Config

logger = Logger()
config = Config()
class JSONStructure:
    def __init__(self):
        self.data_structure: Dict[int, Dict[str, list[Dict[str, any]]]] = {}
        self.end_index: int = -1

    def add_instance(self, time_stamp: str, instance: dict[str, any]) -> None:
        # Check if the timestamp already exists across all indices
        exists = False
        for index_data in self.data_structure.values():
            if time_stamp in index_data:
                # Timestamp already exists, append the instance to the existing timestamp
                index_data[time_stamp].append(instance)
                exists = True
                break
        if not exists:
            # Timestamp is new, create a new entry and increment the end_index
            self.end_index += 1
            self.data_structure.setdefault(self.end_index, {}).setdefault(time_stamp, []).append(instance)

    def search_type_across_all_indices(self, search_type: str) -> list[dict[str, any]]:
        results = []
        for index, index_data in self.data_structure.items():
            for object_id, instances in index_data.items():
                for instance in instances:
                    for type, values in instance.items():
                        if type == search_type:
                            results.append({"index": index, "object_id": object_id, "values":values})
        return results

class VideoFrameExtractor():
    def __init__(self) -> None:
        self.path_vsf = config.VideoFrameExtractor_path
        # copy the placeholder file to the work_dir
        run_placeholderfile_path = os.path.join(config.work_dir, 'test.srt')
        if not os.path.exists(run_placeholderfile_path):
            shutil.copy(config.VideoFrameExtractor_placeholderfile_path, run_placeholderfile_path)
        self.vsf_subtitle = run_placeholderfile_path
        self.frame_output_dir = os.path.join(config.work_dir, 'frame_output_dir')
        self.extracted_frame_folder = os.path.join(self.frame_output_dir, "RGBImages")
        # if self.path_vsf does not exist, throw a non-exist error
        if not os.path.exists(self.path_vsf):
            raise Exception(f"VideoSubFinderWXW does not exist! Please install it according to the README.md.")
        # create a folder to store the extracted frames
        if not os.path.exists(self.frame_output_dir):
            os.makedirs(self.frame_output_dir)

    def delete_frame_cache(self, frame_output_dir):
        # delete the cache of the extracted frames generated by the previous run
        if len(os.listdir(frame_output_dir)) > 0:
            for i in os.listdir(frame_output_dir):
                path = os.path.join(frame_output_dir, i)
                try:
                    if os.path.isfile(path):
                        os.remove(path)
                    elif os.path.isdir(path):
                        shutil.rmtree(path)
                except PermissionError as e:
                    logger.write(f"Permission error: {e}")
                except Exception as e:
                    logger.write(f"An error occurred: {e}")

    def run_sub_finder(self, path_vsf, video_path, frame_output_dir, vsf_subtitle):
        # path_vsf is the path of the VideoSubFinderWXW.exe
        # vsf_subtitile is the path of the extracted sub titles (no usage), it should be ended with '.srt'
        self.delete_frame_cache(frame_output_dir)
        cpu_count = max(int(multiprocessing.cpu_count() * 2 / 3), 1)
        if cpu_count < 4:
            cpu_count = max(multiprocessing.cpu_count() - 1, 1)

        top_end = 0
        bottom_end = 1
        left_end = 0
        right_end = 1
        cmd = f"{path_vsf} --use_cuda -c -r -i \"{video_path}\" -o \"{frame_output_dir}\" -ces \"{vsf_subtitle}\" "
        cmd += f"-te {top_end} -be {bottom_end} -le {left_end} -re {right_end} -nthr {cpu_count} -nocrthr {cpu_count}"

        # Execute the command
        try:
            logger.write(f"Extracting Informative Frames from {video_path} .....")
            result = subprocess.run(cmd, capture_output=True, text=True)
            logger.write(f"Frame Extraction Completed! Total Frames: {len(os.listdir(self.extracted_frame_folder))}")
        except Exception as e:
            logger.write(f"Frame Extraction Failed! {e}")

    def extract(self,video_path):
        video_path = os.path.normpath(video_path)
        self.run_sub_finder(self.path_vsf, video_path, self.frame_output_dir, self.vsf_subtitle)
        # List all files in the directory, get full paths of jpeg files, and extract the first 13 characters of each filename as timestamp
        extracted_frame_paths = [(os.path.join(self.extracted_frame_folder, file), file[:13]) for file in
                                 os.listdir(self.extracted_frame_folder) if
                                 file.endswith('.jpeg') or file.endswith('.jpg')]
        return extracted_frame_paths